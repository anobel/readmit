---
title: "Comorbidity Indices for Predicting Readmissions"
subtitle: "Machine Learning Approaches"
author: "Anobel Y Odisho, Ruth Etzioni, John L Gore"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: cosmo
    css: floating.css
    toc: true
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = T,
  dev = 'quartz_pdf')
```

```{r packages, cache=F}
# Data Cleaning Packages
library(parallel)   # for parallel processing mclapply
options(mc.cores = detectCores()) # set cores to system max

library(dplyr)      # Data Management
library(tidyr)      # Data Cleaning
library(stringr)    # String manipulation
library(broom)      # Tidy regression results

# Graphics Packages
library(knitr)
library(ggplot2)    # Graphics
library(ggthemes)   # Themes for ggplot
library(plotROC)
library(DT)         # HTML Widget for Data Tables
library(stargazer)  # HTML Tables for regression results

# Specialty/Stats Packages
library(ROCR)       # Performance measures, ROC curves, AUC
library(icd)        # ICD package
library(glmnet)
# library(multidplyr)
# library(lme4)     # Mixed Effects Models
# library(coin)     # Permutation Testing
```

```{r functions}
rocResult <- function (x, add=F) {
  # predict test data result from a simple model
  pr <- predict(x, newdata = test, allow.new.levels = T)
  pr <- prediction(pr, test$isreadmit30dc)
  auc <- performance(pr, measure = "auc") 
  auc <- round(auc@y.values[[1]],4)
  # Generate ROC Curve
  roc <- performance(pr, measure="tpr", x.measure = "fpr")
  plot(roc, colorize=T, downsampling = 0.5, add = add)
  abline(0,1, col = "grey")
  cat("AUC:", auc)
}

# Prepare object for ROC plotting from multiple regressions
# Use this when using a single model from a single do() command
# but that is first grouped by cohorts
# the resulting object is in long format
rocLong <- function (modelDF, groupvar) {
  # modelDF takes output from regression model generated by do()
  # groupvar refers to the grouping variable used
  # create vectors for number of groups and to identify groups
  numgroups <- nrow(modelDF)
  group <- unique(modelDF[[groupvar]])
  # predicted results using test data
  pr <- lapply(1:numgroups, function(x) {
          predict(modelDF[[x,2]],
            newdata=test[test[[groupvar]]==group[x],],
            allow.new.levels=T)
          })
  # create the ROCR prediction object. use for calculating TPR/FPR, AUC
  pr <- lapply(1:numgroups, function(x) {
          prediction(pr[[x]],
                    test$isreadmit30dc[test[[groupvar]]==group[x]])
          })
  # Calculate AUCs
  auc <- lapply(1:numgroups, function(x) {
    performance(pr[[x]], measure = "auc")@y.values[[1]]
  })
  # create s4 objeect with TPR and FPR
  pr <- lapply(1:numgroups, function(x) {
          performance(pr[[x]], measure = "tpr", x.measure = "fpr")
          })
  # flatten prediction object into a dataframe with grouping variables and AUC
  results <- list()
  for (i in 1:numgroups) {
    results[[i]] <- data.frame(
           group = group[i],
           fpr = unlist(pr[[i]]@x.values),
           tpr = unlist(pr[[i]]@y.values),
           cutoff = unlist(pr[[i]]@alpha.values),
           auc = auc[[i]])
  }
  results <- do.call(rbind, results)
  return(results)
}

# Prepare object for ROC plotting from multiple regressions
# Use this when generating multiple models for a single cohort
# from multiple do() commands
# the resulting object is in wide format

rocWide <- function (modelDF) {
  # modelDF takes output from regression model generated by do()
  # groupvar refers to the grouping variable used
  # create vectors for number of groups and to identify groups
  numgroups <- length(modelDF)-1
  group = modelDF[[1,1]]
  # predicted results using test data
  pr <- lapply(2:(numgroups+1), function(x) {
          predict(modelDF[[1, x]],
            newdata=test[test$cohort == group, ],
            allow.new.levels = T)
          })
  # create the ROCR prediction object. use for calculating TPR/FPR, AUC
  pr <- lapply(1:numgroups, function(x) {
          prediction(pr[[x]], test$isreadmit30dc[test$cohort==group])
          })
  # Calculate AUCs
  auc <- lapply(1:numgroups, function(x) {
    performance(pr[[x]], measure="auc")@y.values[[1]]
  })
  # create s4 objeect with TPR and FPR
  pr <- lapply(1:numgroups, function(x) {
          performance(pr[[x]], measure="tpr", x.measure="fpr")
          })
  # flatten prediction object into a dataframe with grouping variables and AUC
  results <- list()
  for (i in 1:numgroups) {
    results[[i]] <- data.frame(
           group = names(modelDF)[i+1],
           fpr = unlist(pr[[i]]@x.values),
           tpr = unlist(pr[[i]]@y.values),
           cutoff = unlist(pr[[i]]@alpha.values),
           auc = auc[[i]])
  }
  results <- do.call(rbind, results)
  return(results)
}

# Prepare glmnet model for plotting by ggplot
rocGLMNET <- function(model, test, numcohorts) {
  # model is a glmnet object
  # test is the test matrix
  # create empty lists for prediction, performance, and AUC objects
  library(glmnet)
  library(ROCR)
  pred <- vector("list", numcohorts)
  perf <- vector("list", numcohorts)
  auc <- vector("list", numcohorts)  

  for (i in 1:numcohorts) {
    pred[[i]] <- predict(model[[i]], 
                                type = "response", 
                                s = model[[i]]$lambda.min, 
                                newx = test[[i]]$x)
  pred[[i]] <- prediction(pred[[i]], test[[i]]$y)
  perf[[i]] <- performance(pred[[i]], "tpr", "fpr")
  auc[[i]] <- performance(pred[[i]], "auc")
  }
  # convert nested lists into dataframe
  results <- list()
  for (i in 1:numcohorts) {
    results[[i]] <- data.frame(
          model = deparse(substitute(model)),
          group = cohorts[i],
          fpr = unlist(perf[[i]]@x.values),
          tpr = unlist(perf[[i]]@y.values),
          cutoff = unlist(perf[[i]]@alpha.values),
          auc = unlist(auc[[i]]@y.values),
          row.names = NULL)
  }
  results <- do.call(rbind, results)
  return(results)
}

# Calculate AUCs from a single regression result
aucResult <- function(x) {
  # predict test data result
  pr <- predict(x, newdata=test, allow.new.levels=T)
  pr <- prediction(pr, test$isreadmit30dc)
  auc <- performance(pr, measure="auc") 
  auc <- round(auc@y.values[[1]],4)
  return(auc)
}
```

```{r importdata}
# Import data
pt <- readRDS("data/patient/tidy/pt_rml.rds")

# center variables
pt$agyradm_s <- scale(pt$agyradm)

# split data into training and validation cohorts
# Set random seed to reproduce results
set.seed(7)

# Create an index variable which will allow splitting of training/test data without overlap
pt$index <- seq(1:nrow(pt))

# Group by OSHPD_ID, then take a 75% sample for training set
train <- pt %>%
  group_by(cohort) %>%
  sample_frac(size=0.75, replace=F)

# Anything that didnt make it into training set is put into a test set
test <- pt[!(pt$index %in% train$index),]

# Remove index variables
pt <- pt %>% select(-index)
train <- train %>% select(-index)
test <- test %>% select(-index)
```

```{r constants}
# Define colors for charts
c <- list()
c$dblue <- "#506380"
c$teal <- "#18A3AC"
c$blue <- "#178CCB"
c$orange <- "#F48024"

# HCC names
hccnames <- read.csv("data/raw/hcc/hcc_labels.csv", stringsAsFactors = F)

# Calculate counts
counts <- pt %>%
  group_by(cohort) %>%
  summarise(n = n())

# Make a vector of cohort names
# Will use this for functions/operations
cohorts <- counts$cohort

# Number of cohorts (used in functions/for loops)
numcohorts <- length(cohorts)

# create empty list of terms for later use
terms <- list()

########## Regression Formulas
# save formulas for regression models
elixfm <- paste0(grep("elix_", names(pt), value = T), collapse = "+")
elixfm.full <- as.formula(paste("isreadmit30dc ~ agyradm_s + sex + ", elixfm, sep = ""))
elixfm <- as.formula(paste("isreadmit30dc", elixfm, sep = "~"))

cdfm <- paste0(grep("cd_", names(pt), value = T), collapse = "+")
cdfm.full <- as.formula(paste("isreadmit30dc ~ agyradm_s + sex + ", cdfm, sep = ""))
cdfm <- as.formula(paste("isreadmit30dc", cdfm, sep = "~"))

hccfm <- paste0(grep("hcc_", names(pt), value = T), collapse = "+")
hccfm.full <- as.formula(paste("isreadmit30dc ~ agyradm_s + sex + ", hccfm, sep = ""))
hccfm <- as.formula(paste("isreadmit30dc", hccfm, sep = "~"))
```

# Forward Logistic Model Selection

Using AIC for model selection, 15 maximum steps

## Elixhauser
```{r elixForwardLog, eval=F}
# Create empty data frame to populate with forward logistic results
elixforward <- vector("list", numcohorts)
# fit forward stepwise models for all 4 cohorts
for (i in 1:numcohorts) {
  elixmodeldata <- pt %>% 
    filter(cohort==cohorts[[i]]) %>%
    select(isreadmit30dc, agyradm_s, sex, starts_with("elix_")) %>%
    ungroup()
  glmelixfull = glm(elixfm.full, data=elixmodeldata, family="binomial")
  glmelixempty = glm(isreadmit30dc ~ agyradm_s + sex, data=elixmodeldata, family="binomial")
  elixforward[[i]] <- step(glmelixempty,
                          scope = list(
                            lower = formula(glmelixempty),
                            upper = formula(glmelixfull)),
                          direction = "forward",
                          steps=10)
}

# exponentiate results, calculate confidence intervals
# convert results into a data frame, append cohort names
elixforwardres <- vector("list", numcohorts)
for (i in 1:numcohorts) {
  elixforwardres[[i]] <- cbind(
      cohort = cohorts[[i]],
      tidy(elixforward[[i]], exponentiate = T),
      ci = exp(confint(elixforward[[i]]))
  )
  names(elixforwardres[[i]]) <- c("cohort", "term", "OR", "se", "statistic", "pvalue", "ci.low", "ci.high")
  elixforwardres[[i]] <- elixforwardres[[i]] %>% 
    mutate(term = str_replace_all(term, "elix_|TRUE","")) %>%
    select(cohort, term, OR, ci.low, ci.high, pvalue)
}

elixforwardres <- elixforwardres %>%
  rbind_all() %>%
  gather(variable, value, -cohort, -term) %>%
  mutate(value = round(value, digits=4)) %>%
  unite(cohort_var, cohort, variable) %>%
  spread(cohort_var, value)

# export results
write.csv(elixforwardres, file="exports/elixforward.csv")
  
# display table of results from elixforward regression
kable(elixforwardres)
```

## Charlson
```{r cdForwardLog, eval=F}
# Create empty data frame to populate with forward logistic results
cdforward <- vector("list", numcohorts)
# fit forward stepwise models for all 4 cohorts
for (i in 1:numcohorts) {
  cdmodeldata <- pt %>% 
    filter(cohort==cohorts[[i]]) %>%
    select(isreadmit30dc, agyradm_s, sex, starts_with("cd_")) %>%
    ungroup()
  glmcdfull = glm(cdfm.full, data=cdmodeldata, family="binomial")
  glmcdempty = glm(isreadmit30dc ~ agyradm_s + sex, data=cdmodeldata, family="binomial")
  cdforward[[i]] <- step(glmcdempty,
                          scope = list(
                            lower = formula(glmcdempty),
                            upper = formula(glmcdfull)),
                          direction = "forward",
                          steps=10)
}

# exponentiate results, calculate confidence intervals
# convert results into a data frame, append cohort names
cdforwardres <- vector("list", numcohorts)
for (i in 1:numcohorts) {
  cdforwardres[[i]] <- cbind(
      cohort = cohorts[[i]],
      tidy(cdforward[[i]], exponentiate = T),
      ci = exp(confint(cdforward[[i]]))
  )
  names(cdforwardres[[i]]) <- c("cohort", "term", "OR", "se", "statistic", "pvalue", "ci.low", "ci.high")
  cdforwardres[[i]] <- cdforwardres[[i]] %>% 
    mutate(term = str_replace_all(term, "cd_|TRUE","")) %>%
    select(cohort, term, OR, ci.low, ci.high, pvalue)
}

cdforwardres <- cdforwardres %>%
  rbind_all() %>%
  gather(variable, value, -cohort, -term) %>%
  mutate(value = round(value, digits=4)) %>%
  unite(cohort_var, cohort, variable) %>%
  spread(cohort_var, value)

# export results
write.csv(cdforwardres, file="exports/cdforward.csv")
  
# display table of results from cdforward regression
kable(cdforwardres)
```

## HCC
```{r hccForwardLog, eval=F}
# Create empty data frame to populate with forward logistic results
hccforward <- vector("list", numcohorts)
# fit forward stepwise models for all 4 cohorts
for (i in 1:numcohorts) {
  hccmodeldata <- pt %>% 
    filter(cohort==cohorts[[i]]) %>%
    select(isreadmit30dc, agyradm_s, sex, starts_with("hcc_")) %>%
    ungroup()
  glmhccfull = glm(hccfm.full, data=hccmodeldata, family="binomial")
  glmhccempty = glm(isreadmit30dc ~ agyradm_s + sex, data=hccmodeldata, family="binomial")
  hccforward[[i]] <- step(glmhccempty,
                          scope = list(
                            lower = formula(glmhccempty),
                            upper = formula(glmhccfull)),
                          direction = "forward",
                          steps=10)
}

# exponentiate results, calculate confidence intervals
# convert results into a data frame, append cohort names
hccforwardres <- vector("list", numcohorts)
for (i in 1:numcohorts) {
  hccforwardres[[i]] <- cbind(
      cohort = cohorts[[i]],
      tidy(hccforward[[i]], exponentiate = T),
      ci = exp(confint(hccforward[[i]]))
  )
  names(hccforwardres[[i]]) <- c("cohort", "term", "OR", "se", "statistic", "pvalue", "ci.low", "ci.high")
  hccforwardres[[i]] <- hccforwardres[[i]] %>% 
    mutate(term = str_replace_all(term, "hcc_|TRUE","")) %>%
    select(cohort, term, OR, ci.low, ci.high, pvalue)
}

hccforwardres <- hccforwardres %>%
  rbind_all() %>%
  gather(variable, value, -cohort, -term) %>%
  mutate(value = round(value, digits=4)) %>%
  unite(cohort_var, cohort, variable) %>%
  spread(cohort_var, value)

# export results
write.csv(hccforwardres, file="exports/hccforward.csv")
  
# display table of results from hccforward regression
kable(hccforwardres)
```

# Lasso Model Selection
